<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>エンジニア・研究者の英語学習 - Machine Learning</title><link href="http://englishforhackers.com/" rel="alternate"></link><link href="http://englishforhackers.com/feeds/machine-learning.atom.xml" rel="self"></link><id>http://englishforhackers.com/</id><updated>2018-05-04T00:00:00-04:00</updated><entry><title>機械学習：技術的負債の高金利クレジットカード</title><link href="http://englishforhackers.com/machine-learning-technical-debt.html" rel="alternate"></link><published>2018-05-04T00:00:00-04:00</published><updated>2018-05-04T00:00:00-04:00</updated><author><name>Masato Hagiwara</name></author><id>tag:englishforhackers.com,2018-05-04:/machine-learning-technical-debt.html</id><summary type="html">&lt;p&gt;Google で機械学習システムの開発に携わる D. Scully 氏らによる&lt;/p&gt;
&lt;p&gt;&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf"&gt;Machine Learning: The High-Interest Credit Card of Technical Debt
(機械学習：技術的負債の高金利クレジットカード)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;という論文。機械学習は、複雑なシステムを素早く開発するにあたって非常に強力なツールとなるが、それと同時に、
大きな技術的負債（メンテナンスコスト）を抱えるリスクがある。そのリスク要因と対処法についてまとめたのが本論文。&lt;/p&gt;
&lt;p&gt;発表当時、日本でも少し話題になったので、日本語で検索するといくつか翻訳を目にすることができますが、
ここでは、あらためて抄訳を試みるとともに、読む上で重要となる単語・表現を最後に紹介したいと思います。&lt;/p&gt;
&lt;p&gt;概要&lt;/p&gt;
&lt;p&gt;機械学習は、複雑なシステムを素早く開発するにあたって非常に強力なツールとなるが、これらのメリットがタダで
享受できると考えるのは危ない。機械学習を使う場合、システムのレベルで非常に大きな技術的負債（メンテナンスコスト）
を抱えるリスクがある。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;機械学習と複雑なシステム&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;機械学習パッケージは、通常のコードとして複雑さの問題をはらんでいるのと同時に、
システムレベルで「隠れた」技術的負債を抱える恐れがある。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本論文では、機械学習のコードと、大きなシステムレベルとの間の相互作用に焦点を当てる。
ここに隠れた技術的負債が溜まりやすい …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;Google で機械学習システムの開発に携わる D. Scully 氏らによる&lt;/p&gt;
&lt;p&gt;&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf"&gt;Machine Learning: The High-Interest Credit Card of Technical Debt
(機械学習：技術的負債の高金利クレジットカード)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;という論文。機械学習は、複雑なシステムを素早く開発するにあたって非常に強力なツールとなるが、それと同時に、
大きな技術的負債（メンテナンスコスト）を抱えるリスクがある。そのリスク要因と対処法についてまとめたのが本論文。&lt;/p&gt;
&lt;p&gt;発表当時、日本でも少し話題になったので、日本語で検索するといくつか翻訳を目にすることができますが、
ここでは、あらためて抄訳を試みるとともに、読む上で重要となる単語・表現を最後に紹介したいと思います。&lt;/p&gt;
&lt;p&gt;概要&lt;/p&gt;
&lt;p&gt;機械学習は、複雑なシステムを素早く開発するにあたって非常に強力なツールとなるが、これらのメリットがタダで
享受できると考えるのは危ない。機械学習を使う場合、システムのレベルで非常に大きな技術的負債（メンテナンスコスト）
を抱えるリスクがある。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;機械学習と複雑なシステム&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;機械学習パッケージは、通常のコードとして複雑さの問題をはらんでいるのと同時に、
システムレベルで「隠れた」技術的負債を抱える恐れがある。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本論文では、機械学習のコードと、大きなシステムレベルとの間の相互作用に焦点を当てる。
ここに隠れた技術的負債が溜まりやすい。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;境界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習を使うそもそもの理由は、ソフトウェアのロジックが外部データに依存しているから&lt;/li&gt;
&lt;li&gt;→ 抽象的な振る舞いをデータから分離することができない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.1 もつれ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CACE (Change Anything, Change Everything) の原則：特徴量を変更・追加すると全てが影響を受ける&lt;/li&gt;
&lt;li&gt;特徴量だけではなく、ハイパー・パラメータ（正則化、学習の設定、訓練時のサンプリング等）にも言える&lt;/li&gt;
&lt;li&gt;解決法&lt;ul&gt;
&lt;li&gt;アンサンブル学習を使う&lt;/li&gt;
&lt;li&gt;高次元可視化ツールなどを使い、モデルの予測を観測する&lt;/li&gt;
&lt;li&gt;より高度な正則化法を使う&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ある程度の「もつれ」は、アルゴリズムに関わらず、機械学習に内在的なもの&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.2 隠れたフィードバック・ループ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユーザーの行動等、実世界のデータから訓練された機械学習システムが、実世界に影響を与えること&lt;/li&gt;
&lt;li&gt;例：CTR (クリック率) の予測モデル&lt;/li&gt;
&lt;li&gt;もし、「ユーザーが、先週にクリックしたニュース見出しの数」が特徴量に入っていると・・・。&lt;/li&gt;
&lt;li&gt;注意深く観察し、このようなループを除去すること&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.3 宣言してない使用者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知らないうちに、機械学習システムの予測を他のシステムが利用していることがある&lt;/li&gt;
&lt;li&gt;システムに変更を加えるのがとたんに難しく、コストがかかるようになる&lt;/li&gt;
&lt;li&gt;隠れたフィードバック・ループを作り出してしまうことも&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;データの依存性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェア開発では、依存性が、コードの複雑さを増大させ、技術的負債を作り出す&lt;/li&gt;
&lt;li&gt;機械学習では、データの依存性が負債を作り出す&lt;/li&gt;
&lt;li&gt;データの依存性は、静的解析などによる検出が難しい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.1 不安定なデータの依存性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習システムの入力が、時間が経つにつれて質的に変化することがある&lt;/li&gt;
&lt;li&gt;上記 CACE の原則の通り、機械学習システムに対して、診断しにくい、ときに重大な影響を及ぼす&lt;/li&gt;
&lt;li&gt;解決法: データのコピーにバージョン番号を振り管理する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.2 十分に活用されていないデータの依存性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習システムの精度にたいしてほとんど貢献していない入力や特徴量&lt;/li&gt;
&lt;li&gt;例: 古くなった特徴量、特徴量グループ、ε特徴量 (複雑さに対して精度の向上が小さい特徴量)&lt;/li&gt;
&lt;li&gt;解決法: 各特徴量を除去した場合の影響を定期的に評価する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.3 データ依存性の静的解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静的解析ツールの例 (&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41159.pdf"&gt;論文&lt;/a&gt;) 
  データ源と特徴量にアノテートでき、依存関係の木構造を分析できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.4 修正の伝搬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問題 A に対してモデル a が存在するとき、類似した問題 A' に対して、a を入力として a' を手っ取り早く作る&lt;/li&gt;
&lt;li&gt;a' は a に依存しているため、将来、モデルの改善を分析するのが難しくなる&lt;/li&gt;
&lt;li&gt;a → a' → a'' と何重にもなっている場合、事態はより深刻になる&lt;/li&gt;
&lt;li&gt;解決策: a に特徴量を追加して、修正を直接学習する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;システムレベルのスパゲティ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習システム設計における避けるべきパターン&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.1 グルーコード&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習の汎用パッケージを使うために、入力・出力のために大量のグルーコードが必要になる&lt;/li&gt;
&lt;li&gt;パッケージには利点もあるが、成熟したシステムにおいては、問題空間の構成そのものをリファクタリングしたほうがメリットが大きい&lt;/li&gt;
&lt;li&gt;解決策: システムと同じ言語で、機械学習アルゴリズムを再実装する&lt;/li&gt;
&lt;li&gt;機械学習システムでは、実際に「機械学習」をしている部分は非常に小さい (5%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.2 パイプラインのジャングル&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習のデータを準備するパイプラインが、スクレイパー、結合、サンプリング、中間ファイルなどで乱雑になり、管理・エラー検出・修正などが大変になる&lt;/li&gt;
&lt;li&gt;解決策: データ収集、特徴量抽出に対して、大域的な目で考える。時には、一から再設計することも。&lt;/li&gt;
&lt;li&gt;組織の「研究」と「エンジニアリング」職が離れすぎているのが根本的な原因のことも。&lt;/li&gt;
&lt;li&gt;Google では、エンジニアと研究者を同じチームに「埋め込む」ハイブリッド型研究モデルが、このような技術的負債を未然に防いでいる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.3 古くなった実験的コード&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムなどを、プロダクションコードに対する条件付きブランチとして実験&lt;/li&gt;
&lt;li&gt;一つ一つの変更は、低コストだが、後方互換性の維持などによって、次第に技術的負債となる&lt;/li&gt;
&lt;li&gt;定期的に、削除できないかどうか見直す&lt;/li&gt;
&lt;li&gt;そもそも、実験用のコードはプロダクションコードとは隔離されるべき。再設計・実装が必要かどうか定期的に検討する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.4 設定負債&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どの特徴量・データを使うか、アルゴリズムの設定、前処理、後処理などの設定に負債が溜まる。プロダクションコードに比べ、厳密にテストされてない&lt;/li&gt;
&lt;li&gt;設定不変条件に対するアサーションが役立つことも。２つの設定の diff を左右に並べて表示するツールも役に立つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部世界の変化&lt;/p&gt;
&lt;p&gt;5.1 固定されたしきい値&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;メールがスパムかどうか、広告を表示するかどうかなど、モデルから何らかの決定をする場合、精度・再現率などのトレードオフを考慮しながら、手動で設定&lt;/li&gt;
&lt;li&gt;モデルが更新された場合、そのしきい値が無効になる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.2 相関関係の変化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因果関係にはないが相関関係にある特徴量が、時間が経つにつれ相関関係が無くなると、機械学習システムの予測の振る舞いが変わる&lt;/li&gt;
&lt;li&gt;因果関係ではない相関関係は、隠れた負債となり得る&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.3 監視とテスト&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;単体テストとシステムテストは大切だが、それだけでは不十分。システムの振る舞いをリアルタイムで監視することが必要。&lt;/li&gt;
&lt;li&gt;何を監視するか&lt;ul&gt;
&lt;li&gt;予測バイアス。予測ラベルと実際のラベルの分布を比べる&lt;ul&gt;
&lt;li&gt;完璧ではない。実際のラベルの平均値を出力するだけのベースラインモデルでも、この分布は同じになる&lt;/li&gt;
&lt;li&gt;実際にはとても役に立つ。何かの問題を示唆する場合も。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行動制約&lt;ul&gt;
&lt;li&gt;実世界で何かの行動を起こす場合、監視のため、その行動に制約を設けることが有効なことも&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;負債の支払い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機械学習そのものが悪いとか、何としても技術的負債を防ぐべき、と言っているわけではない&lt;/li&gt;
&lt;li&gt;技術的負債は、エンジニアと研究者の両方が意識すべき問題。精度の向上幅は小さいが、システムの複雑性を大幅に増大させるような研究的な解放は、賢い方法だとは言えない&lt;/li&gt;
&lt;li&gt;複雑な機械学習システムに対し、全体的な視野を持ち、エレガントな解法を解決するのは、とても見返りの大きい仕事である&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;私の所属する組織でも、研究者とエンジニアが同じチームに所属しながら、機械学習をプロダクションに導入していく
埋め込みモデルを採用しています。今のところ、素早いスピードで機械学習をサービスに活かせており、うまく機能しています。&lt;/p&gt;
&lt;p&gt;技術的負債を考える際にも、それをそもそも増大させないための組織論から考えるのが大事ということですね。
&lt;a href="https://en.wikipedia.org/wiki/Conway%27s_law"&gt;「システムのデザインは、その組織のコミュニケーション構造を反映する」という趣旨のコンウェイの法則&lt;/a&gt;にも通じるところがありますね。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;debt&lt;/td&gt;
&lt;td&gt;負債、借金 ("b" を発音しないことに注意)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;incur&lt;/td&gt;
&lt;td&gt;(コストなどを) 被る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound&lt;/td&gt;
&lt;td&gt;悪化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invariant&lt;/td&gt;
&lt;td&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6"&gt;不変条件&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;net&lt;/td&gt;
&lt;td&gt;(ここでは) 正味の、最終的な&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mitigation&lt;/td&gt;
&lt;td&gt;緩和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deleterious&lt;/td&gt;
&lt;td&gt;有害な&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sought&lt;/td&gt;
&lt;td&gt;seek の 過去・過去分詞形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;holistic&lt;/td&gt;
&lt;td&gt;全体的な&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;holistically&lt;/td&gt;
&lt;td&gt;全体的に&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;root cause&lt;/td&gt;
&lt;td&gt;そもそもの原因&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tease apart&lt;/td&gt;
&lt;td&gt;紐解く、抽出する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sanity check&lt;/td&gt;
&lt;td&gt;整合性などのチェック&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pay off / pay down&lt;/td&gt;
&lt;td&gt;(負債を)返す&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content></entry><entry><title>Googleの研究者が教える、良い機械学習プロダクトを実装するための43のルール</title><link href="http://englishforhackers.com/rules-of-machine-learning-best-practices-for-ml-engineering.html" rel="alternate"></link><published>2018-03-25T00:00:00-04:00</published><updated>2018-03-25T00:00:00-04:00</updated><author><name>Masato Hagiwara</name></author><id>tag:englishforhackers.com,2018-03-25:/rules-of-machine-learning-best-practices-for-ml-engineering.html</id><summary type="html">&lt;p&gt;Google のリサーチ・サイエンティストである Martin Zinkevich 氏によって書かれた、機械学習を使った良いプロダクトを開発するためのコツを集めた記事。エンジニアが良い機械学習プロダクトを作るには、機械学習の専門知識が無いことに苦心するのではなく、得意なエンジニアリングの技術を活かすことが重要、というのが主な趣旨です。&lt;/p&gt;
&lt;p&gt;紹介記事：&lt;a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf"&gt;Rules of Machine Learning: Best Practices for ML Engineering&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;はじめに&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ほとんどの問題はエンジニアリングに関する問題である&lt;/li&gt;
&lt;li&gt;性能向上は、良い機械学習のアルゴリズムではなく、良い素性によってもたらされる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械学習の前に&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール1. 本当に必要になるまで機械学習を使わない&lt;/li&gt;
&lt;li&gt;ルール2. まず指標を設計、実装する&lt;/li&gt;
&lt;li&gt;ルール3. ヒューリスティックが複雑になりすぎる前に、機械学習に移行する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;フェーズI: 最初のパイプライン&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール4. 最初のモデルはシンプルに。インフラをまず整える&lt;/li&gt;
&lt;li&gt;ルール5. インフラを機械学習とは独立にテストする&lt;ul&gt;
&lt;li&gt;素性は正しく計算できているか。モデルは訓練環境とテスト環境で同じ値を返すか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール6. パイプラインをコピーする場合は、欠損データに気をつける&lt;/li&gt;
&lt;li&gt;ルール7. ヒューリスティックを素性に変換するか、外部的に扱う …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Google のリサーチ・サイエンティストである Martin Zinkevich 氏によって書かれた、機械学習を使った良いプロダクトを開発するためのコツを集めた記事。エンジニアが良い機械学習プロダクトを作るには、機械学習の専門知識が無いことに苦心するのではなく、得意なエンジニアリングの技術を活かすことが重要、というのが主な趣旨です。&lt;/p&gt;
&lt;p&gt;紹介記事：&lt;a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf"&gt;Rules of Machine Learning: Best Practices for ML Engineering&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;はじめに&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ほとんどの問題はエンジニアリングに関する問題である&lt;/li&gt;
&lt;li&gt;性能向上は、良い機械学習のアルゴリズムではなく、良い素性によってもたらされる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械学習の前に&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール1. 本当に必要になるまで機械学習を使わない&lt;/li&gt;
&lt;li&gt;ルール2. まず指標を設計、実装する&lt;/li&gt;
&lt;li&gt;ルール3. ヒューリスティックが複雑になりすぎる前に、機械学習に移行する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;フェーズI: 最初のパイプライン&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール4. 最初のモデルはシンプルに。インフラをまず整える&lt;/li&gt;
&lt;li&gt;ルール5. インフラを機械学習とは独立にテストする&lt;ul&gt;
&lt;li&gt;素性は正しく計算できているか。モデルは訓練環境とテスト環境で同じ値を返すか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール6. パイプラインをコピーする場合は、欠損データに気をつける&lt;/li&gt;
&lt;li&gt;ルール7. ヒューリスティックを素性に変換するか、外部的に扱う&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;モニタリング&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール8. モデルの即時性に関する要求を把握する&lt;ul&gt;
&lt;li&gt;例：広告やランキングに関するモデルはすぐに古くなる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール9. モデルをデプロイする前に問題を検出する&lt;/li&gt;
&lt;li&gt;ルール10. 「無症状の故障」に気をつける&lt;ul&gt;
&lt;li&gt;例：素性を計算するための統計が古い場合、性能が除々に低下する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール11. 素性グループにオーナーを割り当て、ドキュメントを整える&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最初の目的関数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指標：システムが報告する何らかの数値&lt;/li&gt;
&lt;li&gt;目的関数：機械学習が最適化しようとしている指標&lt;/li&gt;
&lt;li&gt;ルール12. 何を目的関数とするか考えすぎない&lt;/li&gt;
&lt;li&gt;ルール13. 単純で、観察可能な、真の目的関数に帰着可能な指標を選ぶ&lt;ul&gt;
&lt;li&gt;良い例：リンクのクリック率　悪い例：アクティブユーザーの数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール14. 解釈可能なモデルから始め、デバッグを簡単にする&lt;ul&gt;
&lt;li&gt;例：線形・ロジスティック・ポワソン回帰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール15. スパムフィルタとランキングをポリシー層で分ける&lt;ul&gt;
&lt;li&gt;ポリシー層：機械学習に、（単純な）ロジックを追加する層&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;フェーズII: 素性エンジニアリング&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール16. ローンチして、改善する&lt;/li&gt;
&lt;li&gt;ルール17. 学習された素性ではなく、直接観測・報告可能な素性からはじめる&lt;/li&gt;
&lt;li&gt;ルール18. 複数の状況に対して一般化できる素性を試す&lt;/li&gt;
&lt;li&gt;ルール19. 可能なら、非常に特定的な素性を使う&lt;/li&gt;
&lt;li&gt;ルール20. 人間に解釈可能な方法で素性を変換・結合する&lt;ul&gt;
&lt;li&gt;例1. 離散化 → 年齢から年齢層に変換&lt;/li&gt;
&lt;li&gt;例2. 直積 → 素性どうしのデカルト積　性別ｘ国&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール21. 線形モデルで学習可能な素性の数は、データ量に比例&lt;ul&gt;
&lt;li&gt;例：1000インスタンス→10数個の素性&lt;/li&gt;
&lt;li&gt;例：1000万インスタンス→10万素性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール22. 使用されていない素性は削除する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人間による分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール23. あなたは典型的なエンドユーザーではない&lt;ul&gt;
&lt;li&gt;必ずユーザーテストか、実ユーザーで実験する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール24. モデルの「差分」をまず測定する&lt;/li&gt;
&lt;li&gt;ルール25. 予測性能より、実用的な性能を考えてモデルを選ぶ&lt;/li&gt;
&lt;li&gt;ルール26. 誤りパターンを良く観察し、新しい素性を作る&lt;/li&gt;
&lt;li&gt;ルール27. 望まない振る舞いに対しては、定量化してから最適化する&lt;/li&gt;
&lt;li&gt;ルール28. 短期的な振る舞いが同じでも、長期的な振る舞いが同じだとは限らない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;訓練時と提供時の歪み&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供時：モデルの訓練が終わって、その予測をサービス上で実際に使っている時&lt;/li&gt;
&lt;li&gt;ルール29. 訓練時と提供時を同じにするには、提供時に素性をログに出力することで解決&lt;/li&gt;
&lt;li&gt;ルール30. 訓練時にデータを適当に取捨選択するのではなく、重要度サンプリングを使う&lt;/li&gt;
&lt;li&gt;ルール31. テーブルをジョインしている場合は、データが変化する&lt;/li&gt;
&lt;li&gt;ルール32. 訓練パイプラインと提供時のパイプライン間で、なるべくコードを再利用する&lt;/li&gt;
&lt;li&gt;ルール33. モデルを訓練した時に使ったデータよりも新しいデータでテストする&lt;/li&gt;
&lt;li&gt;ルール34. 性能を少し犠牲にしても、綺麗な訓練データを作る&lt;ul&gt;
&lt;li&gt;例：スパムフィルタで、1% を held-out にして必ずユーザーに提示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール35. ランキング問題に内在する歪みに注意する&lt;/li&gt;
&lt;li&gt;ルール36. 位置素性に関するフィードバック・ループに注意&lt;/li&gt;
&lt;li&gt;ルール37. 訓練・提供時の歪みを測定する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;フェーズIII: 鈍化する成長、最適化、複雑なモデル&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ルール38. もし目的関数が合っていないのなら、新しい機能に時間を割かない&lt;/li&gt;
&lt;li&gt;ルール39. ローンチするかの決定は、プロダクトの長期的な目標に合わせる&lt;ul&gt;
&lt;li&gt;ローンチの決定が簡単なのは、全ての指標がよくなった時だけ&lt;/li&gt;
&lt;li&gt;自分が最適化できる指標だけ最大化して満足しない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルール40. アンサンブルモデルは、シンプルに&lt;/li&gt;
&lt;li&gt;ルール41. 性能向上が頭打ちになったら、質的に異なる情報源を探す&lt;/li&gt;
&lt;li&gt;ルール42. コンテンツの人気度と、検索結果の多様性・パーソナリゼーション・関連性には関連があると思わない&lt;/li&gt;
&lt;li&gt;ルール43. ユーザーの友人関係・振る舞いはサービス間で似ているかもしれないが、興味はそうでもない&lt;ul&gt;
&lt;li&gt;パーソナリゼーション素性を異なるプロダクトに持って行ってうまく行ったことがない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用語&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;heuristics&lt;/td&gt;
&lt;td&gt;ヒューリスティック (答えを導くための割と簡単な方法)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fancy&lt;/td&gt;
&lt;td&gt;(手法、モデルなどが) 凝った&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sanity check&lt;/td&gt;
&lt;td&gt;正しさのチェック&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;feature column&lt;/td&gt;
&lt;td&gt;(Google 独自用語) 素性グループ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;proxy&lt;/td&gt;
&lt;td&gt;代替物 (ここでは、真の目的関数ではないが、それに十分近い指標)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;serve&lt;/td&gt;
&lt;td&gt;提供する (訓練した機械学習モデル・システムの予測を実際にプロダクトで使うこと)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content></entry></feed>